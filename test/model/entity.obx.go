// Code generated by ObjectBox; DO NOT EDIT.
// Learn more about defining entities and generating this file - visit https://golang.objectbox.io/entity-annotations

package model

import (
	"github.com/google/flatbuffers/go"
	"github.com/objectbox/objectbox-go/objectbox"
	"github.com/objectbox/objectbox-go/objectbox/fbutils"
)

type entity_EntityInfo struct {
	objectbox.Entity
	Uid uint64
}

var EntityBinding = entity_EntityInfo{
	Entity: objectbox.Entity{
		Id: 1,
	},
	Uid: 3022148985475790732,
}

// Entity_ contains type-based Property helpers to facilitate some common operations such as Queries.
var Entity_ = struct {
	Id              *objectbox.PropertyUint64
	Int             *objectbox.PropertyInt
	Int8            *objectbox.PropertyInt8
	Int16           *objectbox.PropertyInt16
	Int32           *objectbox.PropertyInt32
	Int64           *objectbox.PropertyInt64
	Uint            *objectbox.PropertyUint
	Uint8           *objectbox.PropertyUint8
	Uint16          *objectbox.PropertyUint16
	Uint32          *objectbox.PropertyUint32
	Uint64          *objectbox.PropertyUint64
	Bool            *objectbox.PropertyBool
	String          *objectbox.PropertyString
	StringVector    *objectbox.PropertyStringVector
	Byte            *objectbox.PropertyByte
	ByteVector      *objectbox.PropertyByteVector
	Rune            *objectbox.PropertyRune
	Float32         *objectbox.PropertyFloat32
	Float64         *objectbox.PropertyFloat64
	Date            *objectbox.PropertyInt64
	Complex128      *objectbox.PropertyByteVector
	Related         *objectbox.RelationToOne
	RelatedPtr      *objectbox.RelationToOne
	RelatedPtr2     *objectbox.RelationToOne
	IntPtr          *objectbox.PropertyInt
	Int8Ptr         *objectbox.PropertyInt8
	Int16Ptr        *objectbox.PropertyInt16
	Int32Ptr        *objectbox.PropertyInt32
	Int64Ptr        *objectbox.PropertyInt64
	UintPtr         *objectbox.PropertyUint
	Uint8Ptr        *objectbox.PropertyUint8
	Uint16Ptr       *objectbox.PropertyUint16
	Uint32Ptr       *objectbox.PropertyUint32
	Uint64Ptr       *objectbox.PropertyUint64
	BoolPtr         *objectbox.PropertyBool
	StringPtr       *objectbox.PropertyString
	StringVectorPtr *objectbox.PropertyStringVector
	BytePtr         *objectbox.PropertyByte
	ByteVectorPtr   *objectbox.PropertyByteVector
	RunePtr         *objectbox.PropertyRune
	Float32Ptr      *objectbox.PropertyFloat32
	Float64Ptr      *objectbox.PropertyFloat64
	RelatedPtrSlice *objectbox.RelationToMany
	RelatedSlice    *objectbox.RelationToMany
}{
	Id: &objectbox.PropertyUint64{
		BaseProperty: &objectbox.BaseProperty{
			Id:     1,
			Entity: &EntityBinding.Entity,
		},
	},
	Int: &objectbox.PropertyInt{
		BaseProperty: &objectbox.BaseProperty{
			Id:     2,
			Entity: &EntityBinding.Entity,
		},
	},
	Int8: &objectbox.PropertyInt8{
		BaseProperty: &objectbox.BaseProperty{
			Id:     3,
			Entity: &EntityBinding.Entity,
		},
	},
	Int16: &objectbox.PropertyInt16{
		BaseProperty: &objectbox.BaseProperty{
			Id:     4,
			Entity: &EntityBinding.Entity,
		},
	},
	Int32: &objectbox.PropertyInt32{
		BaseProperty: &objectbox.BaseProperty{
			Id:     5,
			Entity: &EntityBinding.Entity,
		},
	},
	Int64: &objectbox.PropertyInt64{
		BaseProperty: &objectbox.BaseProperty{
			Id:     6,
			Entity: &EntityBinding.Entity,
		},
	},
	Uint: &objectbox.PropertyUint{
		BaseProperty: &objectbox.BaseProperty{
			Id:     7,
			Entity: &EntityBinding.Entity,
		},
	},
	Uint8: &objectbox.PropertyUint8{
		BaseProperty: &objectbox.BaseProperty{
			Id:     8,
			Entity: &EntityBinding.Entity,
		},
	},
	Uint16: &objectbox.PropertyUint16{
		BaseProperty: &objectbox.BaseProperty{
			Id:     9,
			Entity: &EntityBinding.Entity,
		},
	},
	Uint32: &objectbox.PropertyUint32{
		BaseProperty: &objectbox.BaseProperty{
			Id:     10,
			Entity: &EntityBinding.Entity,
		},
	},
	Uint64: &objectbox.PropertyUint64{
		BaseProperty: &objectbox.BaseProperty{
			Id:     11,
			Entity: &EntityBinding.Entity,
		},
	},
	Bool: &objectbox.PropertyBool{
		BaseProperty: &objectbox.BaseProperty{
			Id:     12,
			Entity: &EntityBinding.Entity,
		},
	},
	String: &objectbox.PropertyString{
		BaseProperty: &objectbox.BaseProperty{
			Id:     13,
			Entity: &EntityBinding.Entity,
		},
	},
	StringVector: &objectbox.PropertyStringVector{
		BaseProperty: &objectbox.BaseProperty{
			Id:     21,
			Entity: &EntityBinding.Entity,
		},
	},
	Byte: &objectbox.PropertyByte{
		BaseProperty: &objectbox.BaseProperty{
			Id:     14,
			Entity: &EntityBinding.Entity,
		},
	},
	ByteVector: &objectbox.PropertyByteVector{
		BaseProperty: &objectbox.BaseProperty{
			Id:     15,
			Entity: &EntityBinding.Entity,
		},
	},
	Rune: &objectbox.PropertyRune{
		BaseProperty: &objectbox.BaseProperty{
			Id:     16,
			Entity: &EntityBinding.Entity,
		},
	},
	Float32: &objectbox.PropertyFloat32{
		BaseProperty: &objectbox.BaseProperty{
			Id:     17,
			Entity: &EntityBinding.Entity,
		},
	},
	Float64: &objectbox.PropertyFloat64{
		BaseProperty: &objectbox.BaseProperty{
			Id:     18,
			Entity: &EntityBinding.Entity,
		},
	},
	Date: &objectbox.PropertyInt64{
		BaseProperty: &objectbox.BaseProperty{
			Id:     19,
			Entity: &EntityBinding.Entity,
		},
	},
	Complex128: &objectbox.PropertyByteVector{
		BaseProperty: &objectbox.BaseProperty{
			Id:     20,
			Entity: &EntityBinding.Entity,
		},
	},
	Related: &objectbox.RelationToOne{
		Property: &objectbox.BaseProperty{
			Id:     22,
			Entity: &EntityBinding.Entity,
		},
		Target: &TestEntityRelatedBinding.Entity,
	},
	RelatedPtr: &objectbox.RelationToOne{
		Property: &objectbox.BaseProperty{
			Id:     23,
			Entity: &EntityBinding.Entity,
		},
		Target: &TestEntityRelatedBinding.Entity,
	},
	RelatedPtr2: &objectbox.RelationToOne{
		Property: &objectbox.BaseProperty{
			Id:     24,
			Entity: &EntityBinding.Entity,
		},
		Target: &TestEntityRelatedBinding.Entity,
	},
	IntPtr: &objectbox.PropertyInt{
		BaseProperty: &objectbox.BaseProperty{
			Id:     25,
			Entity: &EntityBinding.Entity,
		},
	},
	Int8Ptr: &objectbox.PropertyInt8{
		BaseProperty: &objectbox.BaseProperty{
			Id:     26,
			Entity: &EntityBinding.Entity,
		},
	},
	Int16Ptr: &objectbox.PropertyInt16{
		BaseProperty: &objectbox.BaseProperty{
			Id:     27,
			Entity: &EntityBinding.Entity,
		},
	},
	Int32Ptr: &objectbox.PropertyInt32{
		BaseProperty: &objectbox.BaseProperty{
			Id:     28,
			Entity: &EntityBinding.Entity,
		},
	},
	Int64Ptr: &objectbox.PropertyInt64{
		BaseProperty: &objectbox.BaseProperty{
			Id:     29,
			Entity: &EntityBinding.Entity,
		},
	},
	UintPtr: &objectbox.PropertyUint{
		BaseProperty: &objectbox.BaseProperty{
			Id:     30,
			Entity: &EntityBinding.Entity,
		},
	},
	Uint8Ptr: &objectbox.PropertyUint8{
		BaseProperty: &objectbox.BaseProperty{
			Id:     31,
			Entity: &EntityBinding.Entity,
		},
	},
	Uint16Ptr: &objectbox.PropertyUint16{
		BaseProperty: &objectbox.BaseProperty{
			Id:     32,
			Entity: &EntityBinding.Entity,
		},
	},
	Uint32Ptr: &objectbox.PropertyUint32{
		BaseProperty: &objectbox.BaseProperty{
			Id:     33,
			Entity: &EntityBinding.Entity,
		},
	},
	Uint64Ptr: &objectbox.PropertyUint64{
		BaseProperty: &objectbox.BaseProperty{
			Id:     34,
			Entity: &EntityBinding.Entity,
		},
	},
	BoolPtr: &objectbox.PropertyBool{
		BaseProperty: &objectbox.BaseProperty{
			Id:     35,
			Entity: &EntityBinding.Entity,
		},
	},
	StringPtr: &objectbox.PropertyString{
		BaseProperty: &objectbox.BaseProperty{
			Id:     36,
			Entity: &EntityBinding.Entity,
		},
	},
	StringVectorPtr: &objectbox.PropertyStringVector{
		BaseProperty: &objectbox.BaseProperty{
			Id:     43,
			Entity: &EntityBinding.Entity,
		},
	},
	BytePtr: &objectbox.PropertyByte{
		BaseProperty: &objectbox.BaseProperty{
			Id:     38,
			Entity: &EntityBinding.Entity,
		},
	},
	ByteVectorPtr: &objectbox.PropertyByteVector{
		BaseProperty: &objectbox.BaseProperty{
			Id:     44,
			Entity: &EntityBinding.Entity,
		},
	},
	RunePtr: &objectbox.PropertyRune{
		BaseProperty: &objectbox.BaseProperty{
			Id:     40,
			Entity: &EntityBinding.Entity,
		},
	},
	Float32Ptr: &objectbox.PropertyFloat32{
		BaseProperty: &objectbox.BaseProperty{
			Id:     41,
			Entity: &EntityBinding.Entity,
		},
	},
	Float64Ptr: &objectbox.PropertyFloat64{
		BaseProperty: &objectbox.BaseProperty{
			Id:     42,
			Entity: &EntityBinding.Entity,
		},
	},
	RelatedPtrSlice: &objectbox.RelationToMany{
		Id:     5,
		Source: &EntityBinding.Entity,
		Target: &TestEntityRelatedBinding.Entity,
	},
	RelatedSlice: &objectbox.RelationToMany{
		Id:     4,
		Source: &EntityBinding.Entity,
		Target: &EntityByValueBinding.Entity,
	},
}

// GeneratorVersion is called by ObjectBox to verify the compatibility of the generator used to generate this code
func (entity_EntityInfo) GeneratorVersion() int {
	return 2
}

// AddToModel is called by ObjectBox during model build
func (entity_EntityInfo) AddToModel(model *objectbox.Model) {
	model.Entity("Entity", 1, 3022148985475790732)
	model.Property("Id", 6, 1, 1213346202559552829)
	model.PropertyFlags(8193)
	model.Property("Int", 6, 2, 6609825840127351046)
	model.Property("Int8", 2, 3, 741904540265547276)
	model.Property("Int16", 3, 4, 2102961483425256790)
	model.Property("Int32", 5, 5, 5086065890743931723)
	model.Property("Int64", 6, 6, 7993850425898343586)
	model.Property("Uint", 6, 7, 993618338451248101)
	model.PropertyFlags(8192)
	model.Property("Uint8", 2, 8, 8794162191867215541)
	model.PropertyFlags(8192)
	model.Property("Uint16", 3, 9, 8820932096807845950)
	model.PropertyFlags(8192)
	model.Property("Uint32", 5, 10, 6060435196424462358)
	model.PropertyFlags(8192)
	model.Property("Uint64", 6, 11, 6159011311237949479)
	model.PropertyFlags(8192)
	model.Property("Bool", 1, 12, 13717766026420552)
	model.Property("String", 9, 13, 3525810560076343996)
	model.Property("StringVector", 30, 21, 3893192683529392073)
	model.Property("Byte", 2, 14, 4035373893984224671)
	model.Property("ByteVector", 23, 15, 1294888641203478533)
	model.Property("Rune", 5, 16, 445652208596094853)
	model.Property("Float32", 7, 17, 2321055489159952634)
	model.Property("Float64", 8, 18, 681625187526498317)
	model.Property("Date", 10, 19, 2927532418453906842)
	model.Property("Complex128", 23, 20, 2323084480359838337)
	model.Property("Related", 11, 22, 6981354105569415135)
	model.PropertyFlags(8192)
	model.PropertyRelation("TestEntityRelated", 1, 7297830522090799401)
	model.Property("RelatedPtr", 11, 23, 2938782103279095882)
	model.PropertyFlags(8192)
	model.PropertyRelation("TestEntityRelated", 2, 1636618737379039866)
	model.Property("RelatedPtr2", 11, 24, 7776035803207726954)
	model.PropertyFlags(8192)
	model.PropertyRelation("TestEntityRelated", 3, 6077259218141868916)
	model.Property("IntPtr", 6, 25, 373339162565757738)
	model.Property("Int8Ptr", 2, 26, 4408376776468442700)
	model.Property("Int16Ptr", 3, 27, 7767638672655087796)
	model.Property("Int32Ptr", 5, 28, 4484862171635994061)
	model.Property("Int64Ptr", 6, 29, 5702162443518573921)
	model.Property("UintPtr", 6, 30, 1419849538019864166)
	model.PropertyFlags(8192)
	model.Property("Uint8Ptr", 2, 31, 5666684665126533193)
	model.PropertyFlags(8192)
	model.Property("Uint16Ptr", 3, 32, 588273992483456755)
	model.PropertyFlags(8192)
	model.Property("Uint32Ptr", 5, 33, 1921936640604795696)
	model.PropertyFlags(8192)
	model.Property("Uint64Ptr", 6, 34, 508303024901376893)
	model.PropertyFlags(8192)
	model.Property("BoolPtr", 1, 35, 8481118512070824875)
	model.Property("StringPtr", 9, 36, 8409889434685629914)
	model.Property("StringVectorPtr", 30, 43, 4222000762705400780)
	model.Property("BytePtr", 2, 38, 7395768407310126147)
	model.Property("ByteVectorPtr", 23, 44, 6100401720382402484)
	model.Property("RunePtr", 5, 40, 5826738612842297282)
	model.Property("Float32Ptr", 7, 41, 8081176555310747578)
	model.Property("Float64Ptr", 8, 42, 9203830121246076395)
	model.EntityLastPropertyId(44, 6100401720382402484)
	model.Relation(5, 1694321226239708534, TestEntityRelatedBinding.Id, TestEntityRelatedBinding.Uid)
	model.Relation(4, 5379891792880176678, EntityByValueBinding.Id, EntityByValueBinding.Uid)
}

// GetId is called by ObjectBox during Put operations to check for existing ID on an object
func (entity_EntityInfo) GetId(object interface{}) (uint64, error) {
	return object.(*Entity).Id, nil
}

// SetId is called by ObjectBox during Put to update an ID on an object that has just been inserted
func (entity_EntityInfo) SetId(object interface{}, id uint64) {
	object.(*Entity).Id = id
}

// PutRelated is called by ObjectBox to put related entities before the object itself is flattened and put
func (entity_EntityInfo) PutRelated(ob *objectbox.ObjectBox, object interface{}, id uint64) error {
	if rel := &object.(*Entity).Related; rel != nil {
		if rId, err := TestEntityRelatedBinding.GetId(rel); err != nil {
			return err
		} else if rId == 0 {
			// NOTE Put/PutAsync() has a side-effect of setting the rel.ID
			if _, err := BoxForTestEntityRelated(ob).Put(rel); err != nil {
				return err
			}
		}
	}
	if rel := object.(*Entity).RelatedPtr; rel != nil {
		if rId, err := TestEntityRelatedBinding.GetId(rel); err != nil {
			return err
		} else if rId == 0 {
			// NOTE Put/PutAsync() has a side-effect of setting the rel.ID
			if _, err := BoxForTestEntityRelated(ob).Put(rel); err != nil {
				return err
			}
		}
	}
	if rel := object.(*Entity).RelatedPtr2; rel != nil {
		if rId, err := TestEntityRelatedBinding.GetId(rel); err != nil {
			return err
		} else if rId == 0 {
			// NOTE Put/PutAsync() has a side-effect of setting the rel.ID
			if _, err := BoxForTestEntityRelated(ob).Put(rel); err != nil {
				return err
			}
		}
	}
	if err := BoxForEntity(ob).RelationReplace(Entity_.RelatedSlice, id, object, object.(*Entity).RelatedSlice); err != nil {
		return err
	}
	if object.(*Entity).RelatedPtrSlice != nil { // lazy-loaded relations without EntityBox::FetchRelatedPtrSlice() called are nil
		if err := BoxForEntity(ob).RelationReplace(Entity_.RelatedPtrSlice, id, object, object.(*Entity).RelatedPtrSlice); err != nil {
			return err
		}
	}
	return nil
}

// Flatten is called by ObjectBox to transform an object to a FlatBuffer
func (entity_EntityInfo) Flatten(object interface{}, fbb *flatbuffers.Builder, id uint64) error {
	obj := object.(*Entity)
	var offsetString = fbutils.CreateStringOffset(fbb, obj.String)
	var offsetStringVector = fbutils.CreateStringVectorOffset(fbb, obj.StringVector)
	var offsetByteVector = fbutils.CreateByteVectorOffset(fbb, obj.ByteVector)
	var offsetComplex128 = fbutils.CreateByteVectorOffset(fbb, complex128BytesToDatabaseValue(obj.Complex128))
	var offsetStringPtr flatbuffers.UOffsetT
	if obj.StringPtr != nil {
		offsetStringPtr = fbutils.CreateStringOffset(fbb, *obj.StringPtr)
	}
	var offsetStringVectorPtr flatbuffers.UOffsetT
	if obj.StringVectorPtr != nil {
		offsetStringVectorPtr = fbutils.CreateStringVectorOffset(fbb, *obj.StringVectorPtr)
	}
	var offsetByteVectorPtr flatbuffers.UOffsetT
	if obj.ByteVectorPtr != nil {
		offsetByteVectorPtr = fbutils.CreateByteVectorOffset(fbb, *obj.ByteVectorPtr)
	}

	var rIdRelated uint64
	if rel := &obj.Related; rel != nil {
		if rId, err := TestEntityRelatedBinding.GetId(rel); err != nil {
			return err
		} else {
			rIdRelated = rId
		}
	}

	var rIdRelatedPtr uint64
	if rel := obj.RelatedPtr; rel != nil {
		if rId, err := TestEntityRelatedBinding.GetId(rel); err != nil {
			return err
		} else {
			rIdRelatedPtr = rId
		}
	}

	var rIdRelatedPtr2 uint64
	if rel := obj.RelatedPtr2; rel != nil {
		if rId, err := TestEntityRelatedBinding.GetId(rel); err != nil {
			return err
		} else {
			rIdRelatedPtr2 = rId
		}
	}

	// build the FlatBuffers object
	fbb.StartObject(44)
	fbutils.SetUint64Slot(fbb, 0, id)
	fbutils.SetInt64Slot(fbb, 1, int64(obj.Int))
	fbutils.SetInt8Slot(fbb, 2, obj.Int8)
	fbutils.SetInt16Slot(fbb, 3, obj.Int16)
	fbutils.SetInt32Slot(fbb, 4, obj.Int32)
	fbutils.SetInt64Slot(fbb, 5, obj.Int64)
	fbutils.SetUint64Slot(fbb, 6, uint64(obj.Uint))
	fbutils.SetUint8Slot(fbb, 7, obj.Uint8)
	fbutils.SetUint16Slot(fbb, 8, obj.Uint16)
	fbutils.SetUint32Slot(fbb, 9, obj.Uint32)
	fbutils.SetUint64Slot(fbb, 10, obj.Uint64)
	fbutils.SetBoolSlot(fbb, 11, obj.Bool)
	fbutils.SetUOffsetTSlot(fbb, 12, offsetString)
	fbutils.SetUOffsetTSlot(fbb, 20, offsetStringVector)
	fbutils.SetByteSlot(fbb, 13, obj.Byte)
	fbutils.SetUOffsetTSlot(fbb, 14, offsetByteVector)
	fbutils.SetInt32Slot(fbb, 15, obj.Rune)
	fbutils.SetFloat32Slot(fbb, 16, obj.Float32)
	fbutils.SetFloat64Slot(fbb, 17, obj.Float64)
	fbutils.SetInt64Slot(fbb, 18, timeInt64ToDatabaseValue(obj.Date))
	fbutils.SetUOffsetTSlot(fbb, 19, offsetComplex128)
	fbutils.SetUint64Slot(fbb, 21, rIdRelated)
	if obj.RelatedPtr != nil {
		fbutils.SetUint64Slot(fbb, 22, rIdRelatedPtr)
	}
	if obj.RelatedPtr2 != nil {
		fbutils.SetUint64Slot(fbb, 23, rIdRelatedPtr2)
	}
	if obj.IntPtr != nil {
		fbutils.SetInt64Slot(fbb, 24, int64(*obj.IntPtr))
	}
	if obj.Int8Ptr != nil {
		fbutils.SetInt8Slot(fbb, 25, *obj.Int8Ptr)
	}
	if obj.Int16Ptr != nil {
		fbutils.SetInt16Slot(fbb, 26, *obj.Int16Ptr)
	}
	if obj.Int32Ptr != nil {
		fbutils.SetInt32Slot(fbb, 27, *obj.Int32Ptr)
	}
	if obj.Int64Ptr != nil {
		fbutils.SetInt64Slot(fbb, 28, *obj.Int64Ptr)
	}
	if obj.UintPtr != nil {
		fbutils.SetUint64Slot(fbb, 29, uint64(*obj.UintPtr))
	}
	if obj.Uint8Ptr != nil {
		fbutils.SetUint8Slot(fbb, 30, *obj.Uint8Ptr)
	}
	if obj.Uint16Ptr != nil {
		fbutils.SetUint16Slot(fbb, 31, *obj.Uint16Ptr)
	}
	if obj.Uint32Ptr != nil {
		fbutils.SetUint32Slot(fbb, 32, *obj.Uint32Ptr)
	}
	if obj.Uint64Ptr != nil {
		fbutils.SetUint64Slot(fbb, 33, *obj.Uint64Ptr)
	}
	if obj.BoolPtr != nil {
		fbutils.SetBoolSlot(fbb, 34, *obj.BoolPtr)
	}
	if obj.StringPtr != nil {
		fbutils.SetUOffsetTSlot(fbb, 35, offsetStringPtr)
	}
	if obj.StringVectorPtr != nil {
		fbutils.SetUOffsetTSlot(fbb, 42, offsetStringVectorPtr)
	}
	if obj.BytePtr != nil {
		fbutils.SetByteSlot(fbb, 37, *obj.BytePtr)
	}
	if obj.ByteVectorPtr != nil {
		fbutils.SetUOffsetTSlot(fbb, 43, offsetByteVectorPtr)
	}
	if obj.RunePtr != nil {
		fbutils.SetInt32Slot(fbb, 39, *obj.RunePtr)
	}
	if obj.Float32Ptr != nil {
		fbutils.SetFloat32Slot(fbb, 40, *obj.Float32Ptr)
	}
	if obj.Float64Ptr != nil {
		fbutils.SetFloat64Slot(fbb, 41, *obj.Float64Ptr)
	}
	return nil
}

// Load is called by ObjectBox to load an object from a FlatBuffer
func (entity_EntityInfo) Load(ob *objectbox.ObjectBox, bytes []byte) (interface{}, error) {
	var table = &flatbuffers.Table{
		Bytes: bytes,
		Pos:   flatbuffers.GetUOffsetT(bytes),
	}
	var id = table.GetUint64Slot(4, 0)

	var relRelated *TestEntityRelated
	if rId := fbutils.GetUint64Slot(table, 46); rId > 0 {
		if rObject, err := BoxForTestEntityRelated(ob).Get(rId); err != nil {
			return nil, err
		} else {
			relRelated = rObject
		}
	} else {
		relRelated = &TestEntityRelated{}
	}

	var relRelatedPtr *TestEntityRelated
	if rId := fbutils.GetUint64PtrSlot(table, 48); rId != nil && *rId > 0 {
		if rObject, err := BoxForTestEntityRelated(ob).Get(*rId); err != nil {
			return nil, err
		} else {
			relRelatedPtr = rObject
		}
	}

	var relRelatedPtr2 *TestEntityRelated
	if rId := fbutils.GetUint64PtrSlot(table, 50); rId != nil && *rId > 0 {
		if rObject, err := BoxForTestEntityRelated(ob).Get(*rId); err != nil {
			return nil, err
		} else {
			relRelatedPtr2 = rObject
		}
	}

	var relRelatedSlice []EntityByValue
	if rIds, err := BoxForEntity(ob).RelationIds(Entity_.RelatedSlice, id); err != nil {
		return nil, err
	} else if rSlice, err := BoxForEntityByValue(ob).GetMany(rIds...); err != nil {
		return nil, err
	} else {
		relRelatedSlice = rSlice
	}

	return &Entity{
		Id:              id,
		Int:             fbutils.GetIntSlot(table, 6),
		Int8:            fbutils.GetInt8Slot(table, 8),
		Int16:           fbutils.GetInt16Slot(table, 10),
		Int32:           fbutils.GetInt32Slot(table, 12),
		Int64:           fbutils.GetInt64Slot(table, 14),
		Uint:            fbutils.GetUintSlot(table, 16),
		Uint8:           fbutils.GetUint8Slot(table, 18),
		Uint16:          fbutils.GetUint16Slot(table, 20),
		Uint32:          fbutils.GetUint32Slot(table, 22),
		Uint64:          fbutils.GetUint64Slot(table, 24),
		Bool:            fbutils.GetBoolSlot(table, 26),
		String:          fbutils.GetStringSlot(table, 28),
		StringVector:    fbutils.GetStringVectorSlot(table, 44),
		Byte:            fbutils.GetByteSlot(table, 30),
		ByteVector:      fbutils.GetByteVectorSlot(table, 32),
		Rune:            fbutils.GetRuneSlot(table, 34),
		Float32:         fbutils.GetFloat32Slot(table, 36),
		Float64:         fbutils.GetFloat64Slot(table, 38),
		Date:            timeInt64ToEntityProperty(fbutils.GetInt64Slot(table, 40)),
		Complex128:      complex128BytesToEntityProperty(fbutils.GetByteVectorSlot(table, 42)),
		Related:         *relRelated,
		RelatedPtr:      relRelatedPtr,
		RelatedPtr2:     relRelatedPtr2,
		RelatedSlice:    relRelatedSlice,
		RelatedPtrSlice: nil, // use EntityBox::FetchRelatedPtrSlice() to fetch this lazy-loaded relation
		IntPtr:          fbutils.GetIntPtrSlot(table, 52),
		Int8Ptr:         fbutils.GetInt8PtrSlot(table, 54),
		Int16Ptr:        fbutils.GetInt16PtrSlot(table, 56),
		Int32Ptr:        fbutils.GetInt32PtrSlot(table, 58),
		Int64Ptr:        fbutils.GetInt64PtrSlot(table, 60),
		UintPtr:         fbutils.GetUintPtrSlot(table, 62),
		Uint8Ptr:        fbutils.GetUint8PtrSlot(table, 64),
		Uint16Ptr:       fbutils.GetUint16PtrSlot(table, 66),
		Uint32Ptr:       fbutils.GetUint32PtrSlot(table, 68),
		Uint64Ptr:       fbutils.GetUint64PtrSlot(table, 70),
		BoolPtr:         fbutils.GetBoolPtrSlot(table, 72),
		StringPtr:       fbutils.GetStringPtrSlot(table, 74),
		StringVectorPtr: fbutils.GetStringVectorPtrSlot(table, 88),
		BytePtr:         fbutils.GetBytePtrSlot(table, 78),
		ByteVectorPtr:   fbutils.GetByteVectorPtrSlot(table, 90),
		RunePtr:         fbutils.GetRunePtrSlot(table, 82),
		Float32Ptr:      fbutils.GetFloat32PtrSlot(table, 84),
		Float64Ptr:      fbutils.GetFloat64PtrSlot(table, 86),
	}, nil
}

// MakeSlice is called by ObjectBox to construct a new slice to hold the read objects
func (entity_EntityInfo) MakeSlice(capacity int) interface{} {
	return make([]*Entity, 0, capacity)
}

// AppendToSlice is called by ObjectBox to fill the slice of the read objects
func (entity_EntityInfo) AppendToSlice(slice interface{}, object interface{}) interface{} {
	return append(slice.([]*Entity), object.(*Entity))
}

// Box provides CRUD access to Entity objects
type EntityBox struct {
	*objectbox.Box
}

// BoxForEntity opens a box of Entity objects
func BoxForEntity(ob *objectbox.ObjectBox) *EntityBox {
	return &EntityBox{
		Box: ob.InternalBox(1),
	}
}

// Put synchronously inserts/updates a single object.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the Entity.Id property on the passed object will be assigned the new ID as well.
func (box *EntityBox) Put(object *Entity) (uint64, error) {
	return box.Box.Put(object)
}

// PutAsync asynchronously inserts/updates a single object.
// When inserting, the Entity.Id property on the passed object will be assigned the new ID as well.
//
// It's executed on a separate internal thread for better performance.
//
// There are two main use cases:
//
// 1) "Put & Forget:" you gain faster puts as you don't have to wait for the transaction to finish.
//
// 2) Many small transactions: if your write load is typically a lot of individual puts that happen in parallel,
// this will merge small transactions into bigger ones. This results in a significant gain in overall throughput.
//
//
// In situations with (extremely) high async load, this method may be throttled (~1ms) or delayed (<1s).
// In the unlikely event that the object could not be enqueued after delaying, an error will be returned.
//
// Note that this method does not give you hard durability guarantees like the synchronous Put provides.
// There is a small time window (typically 3 ms) in which the data may not have been committed durably yet.
func (box *EntityBox) PutAsync(object *Entity) (uint64, error) {
	return box.Box.PutAsync(object)
}

// PutMany inserts multiple objects in single transaction.
// In case Ids are not set on the objects, they would be assigned automatically (auto-increment).
//
// Returns: IDs of the put objects (in the same order).
// When inserting, the Entity.Id property on the objects in the slice will be assigned the new IDs as well.
//
// Note: In case an error occurs during the transaction, some of the objects may already have the Entity.Id assigned
// even though the transaction has been rolled back and the objects are not stored under those IDs.
//
// Note: The slice may be empty or even nil; in both cases, an empty IDs slice and no error is returned.
func (box *EntityBox) PutMany(objects []*Entity) ([]uint64, error) {
	return box.Box.PutMany(objects)
}

// Get reads a single object.
//
// Returns nil (and no error) in case the object with the given ID doesn't exist.
func (box *EntityBox) Get(id uint64) (*Entity, error) {
	object, err := box.Box.Get(id)
	if err != nil {
		return nil, err
	} else if object == nil {
		return nil, nil
	}
	return object.(*Entity), nil
}

// GetMany reads multiple objects at once.
// If any of the objects doesn't exist, its position in the return slice is nil
func (box *EntityBox) GetMany(ids ...uint64) ([]*Entity, error) {
	objects, err := box.Box.GetMany(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*Entity), nil
}

// GetAll reads all stored objects
func (box *EntityBox) GetAll() ([]*Entity, error) {
	objects, err := box.Box.GetAll()
	if err != nil {
		return nil, err
	}
	return objects.([]*Entity), nil
}

// FetchRelatedPtrSlice reads target objects for relation Entity::RelatedPtrSlice.
// It will "GetMany()" all related TestEntityRelated objects for each source object
// and set sourceObject.RelatedPtrSlice to the slice of related objects, as currently stored in DB.
func (box *EntityBox) FetchRelatedPtrSlice(sourceObjects ...*Entity) error {
	return box.ObjectBox.RunInReadTx(func() error {
		// collect slices before setting the source objects' fields
		// this keeps all the sourceObjects untouched in case there's an error during any of the requests
		var slices = make([][]*TestEntityRelated, len(sourceObjects))
		for k, object := range sourceObjects {
			rIds, err := box.RelationIds(Entity_.RelatedPtrSlice, object.Id)
			if err == nil {
				slices[k], err = BoxForTestEntityRelated(box.ObjectBox).GetMany(rIds...)
			}
			if err != nil {
				return err
			}
		}

		// update the field on each of the objects
		// this is really fast so it doesn't hurt to do inside a Tx even though it's unnecessary, consistency-wise
		for k := range sourceObjects {
			sourceObjects[k].RelatedPtrSlice = slices[k]
		}

		return nil
	})
}

// Remove deletes a single object
func (box *EntityBox) Remove(object *Entity) error {
	return box.Box.Remove(object)
}

// RemoveMany deletes multiple objects at once.
// Returns the number of deleted object or error on failure.
// Note that this method will not fail if an object is not found (e.g. already removed).
// In case you need to strictly check whether all of the objects exist before removing them,
// you can execute multiple box.Contains() and box.Remove() inside a single write transaction.
func (box *EntityBox) RemoveMany(objects ...*Entity) (uint64, error) {
	var ids = make([]uint64, len(objects))
	for k, object := range objects {
		ids[k] = object.Id
	}
	return box.Box.RemoveIds(ids...)
}

// Creates a query with the given conditions. Use the fields of the Entity_ struct to create conditions.
// Keep the *EntityQuery if you intend to execute the query multiple times.
// Note: this function panics if you try to create illegal queries; e.g. use properties of an alien type.
// This is typically a programming error. Use QueryOrError instead if you want the explicit error check.
func (box *EntityBox) Query(conditions ...objectbox.Condition) *EntityQuery {
	return &EntityQuery{
		box.Box.Query(conditions...),
	}
}

// Creates a query with the given conditions. Use the fields of the Entity_ struct to create conditions.
// Keep the *EntityQuery if you intend to execute the query multiple times.
func (box *EntityBox) QueryOrError(conditions ...objectbox.Condition) (*EntityQuery, error) {
	if query, err := box.Box.QueryOrError(conditions...); err != nil {
		return nil, err
	} else {
		return &EntityQuery{query}, nil
	}
}

// Query provides a way to search stored objects
//
// For example, you can find all Entity which Id is either 42 or 47:
// 		box.Query(Entity_.Id.In(42, 47)).Find()
type EntityQuery struct {
	*objectbox.Query
}

// Find returns all objects matching the query
func (query *EntityQuery) Find() ([]*Entity, error) {
	objects, err := query.Query.Find()
	if err != nil {
		return nil, err
	}
	return objects.([]*Entity), nil
}

// Offset defines the index of the first object to process (how many objects to skip)
func (query *EntityQuery) Offset(offset uint64) *EntityQuery {
	query.Query.Offset(offset)
	return query
}

// Limit sets the number of elements to process by the query
func (query *EntityQuery) Limit(limit uint64) *EntityQuery {
	query.Query.Limit(limit)
	return query
}

type testStringIdEntity_EntityInfo struct {
	objectbox.Entity
	Uid uint64
}

var TestStringIdEntityBinding = testStringIdEntity_EntityInfo{
	Entity: objectbox.Entity{
		Id: 2,
	},
	Uid: 5412225159475839048,
}

// TestStringIdEntity_ contains type-based Property helpers to facilitate some common operations such as Queries.
var TestStringIdEntity_ = struct {
	Id *objectbox.PropertyUint64
}{
	Id: &objectbox.PropertyUint64{
		BaseProperty: &objectbox.BaseProperty{
			Id:     1,
			Entity: &TestStringIdEntityBinding.Entity,
		},
	},
}

// GeneratorVersion is called by ObjectBox to verify the compatibility of the generator used to generate this code
func (testStringIdEntity_EntityInfo) GeneratorVersion() int {
	return 2
}

// AddToModel is called by ObjectBox during model build
func (testStringIdEntity_EntityInfo) AddToModel(model *objectbox.Model) {
	model.Entity("TestStringIdEntity", 2, 5412225159475839048)
	model.Property("Id", 6, 1, 4639124040173808562)
	model.PropertyFlags(8193)
	model.EntityLastPropertyId(1, 4639124040173808562)
}

// GetId is called by ObjectBox during Put operations to check for existing ID on an object
func (testStringIdEntity_EntityInfo) GetId(object interface{}) (uint64, error) {
	return objectbox.StringIdConvertToDatabaseValue(object.(*TestStringIdEntity).Id), nil
}

// SetId is called by ObjectBox during Put to update an ID on an object that has just been inserted
func (testStringIdEntity_EntityInfo) SetId(object interface{}, id uint64) {
	object.(*TestStringIdEntity).Id = objectbox.StringIdConvertToEntityProperty(id)
}

// PutRelated is called by ObjectBox to put related entities before the object itself is flattened and put
func (testStringIdEntity_EntityInfo) PutRelated(ob *objectbox.ObjectBox, object interface{}, id uint64) error {
	return nil
}

// Flatten is called by ObjectBox to transform an object to a FlatBuffer
func (testStringIdEntity_EntityInfo) Flatten(object interface{}, fbb *flatbuffers.Builder, id uint64) error {

	// build the FlatBuffers object
	fbb.StartObject(1)
	fbutils.SetUint64Slot(fbb, 0, id)
	return nil
}

// Load is called by ObjectBox to load an object from a FlatBuffer
func (testStringIdEntity_EntityInfo) Load(ob *objectbox.ObjectBox, bytes []byte) (interface{}, error) {
	var table = &flatbuffers.Table{
		Bytes: bytes,
		Pos:   flatbuffers.GetUOffsetT(bytes),
	}
	var id = table.GetUint64Slot(4, 0)

	return &TestStringIdEntity{
		Id: objectbox.StringIdConvertToEntityProperty(id),
	}, nil
}

// MakeSlice is called by ObjectBox to construct a new slice to hold the read objects
func (testStringIdEntity_EntityInfo) MakeSlice(capacity int) interface{} {
	return make([]*TestStringIdEntity, 0, capacity)
}

// AppendToSlice is called by ObjectBox to fill the slice of the read objects
func (testStringIdEntity_EntityInfo) AppendToSlice(slice interface{}, object interface{}) interface{} {
	return append(slice.([]*TestStringIdEntity), object.(*TestStringIdEntity))
}

// Box provides CRUD access to TestStringIdEntity objects
type TestStringIdEntityBox struct {
	*objectbox.Box
}

// BoxForTestStringIdEntity opens a box of TestStringIdEntity objects
func BoxForTestStringIdEntity(ob *objectbox.ObjectBox) *TestStringIdEntityBox {
	return &TestStringIdEntityBox{
		Box: ob.InternalBox(2),
	}
}

// Put synchronously inserts/updates a single object.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the TestStringIdEntity.Id property on the passed object will be assigned the new ID as well.
func (box *TestStringIdEntityBox) Put(object *TestStringIdEntity) (uint64, error) {
	return box.Box.Put(object)
}

// PutAsync asynchronously inserts/updates a single object.
// When inserting, the TestStringIdEntity.Id property on the passed object will be assigned the new ID as well.
//
// It's executed on a separate internal thread for better performance.
//
// There are two main use cases:
//
// 1) "Put & Forget:" you gain faster puts as you don't have to wait for the transaction to finish.
//
// 2) Many small transactions: if your write load is typically a lot of individual puts that happen in parallel,
// this will merge small transactions into bigger ones. This results in a significant gain in overall throughput.
//
//
// In situations with (extremely) high async load, this method may be throttled (~1ms) or delayed (<1s).
// In the unlikely event that the object could not be enqueued after delaying, an error will be returned.
//
// Note that this method does not give you hard durability guarantees like the synchronous Put provides.
// There is a small time window (typically 3 ms) in which the data may not have been committed durably yet.
func (box *TestStringIdEntityBox) PutAsync(object *TestStringIdEntity) (uint64, error) {
	return box.Box.PutAsync(object)
}

// PutMany inserts multiple objects in single transaction.
// In case Ids are not set on the objects, they would be assigned automatically (auto-increment).
//
// Returns: IDs of the put objects (in the same order).
// When inserting, the TestStringIdEntity.Id property on the objects in the slice will be assigned the new IDs as well.
//
// Note: In case an error occurs during the transaction, some of the objects may already have the TestStringIdEntity.Id assigned
// even though the transaction has been rolled back and the objects are not stored under those IDs.
//
// Note: The slice may be empty or even nil; in both cases, an empty IDs slice and no error is returned.
func (box *TestStringIdEntityBox) PutMany(objects []*TestStringIdEntity) ([]uint64, error) {
	return box.Box.PutMany(objects)
}

// Get reads a single object.
//
// Returns nil (and no error) in case the object with the given ID doesn't exist.
func (box *TestStringIdEntityBox) Get(id uint64) (*TestStringIdEntity, error) {
	object, err := box.Box.Get(id)
	if err != nil {
		return nil, err
	} else if object == nil {
		return nil, nil
	}
	return object.(*TestStringIdEntity), nil
}

// GetMany reads multiple objects at once.
// If any of the objects doesn't exist, its position in the return slice is nil
func (box *TestStringIdEntityBox) GetMany(ids ...uint64) ([]*TestStringIdEntity, error) {
	objects, err := box.Box.GetMany(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*TestStringIdEntity), nil
}

// GetAll reads all stored objects
func (box *TestStringIdEntityBox) GetAll() ([]*TestStringIdEntity, error) {
	objects, err := box.Box.GetAll()
	if err != nil {
		return nil, err
	}
	return objects.([]*TestStringIdEntity), nil
}

// Remove deletes a single object
func (box *TestStringIdEntityBox) Remove(object *TestStringIdEntity) error {
	return box.Box.Remove(object)
}

// RemoveMany deletes multiple objects at once.
// Returns the number of deleted object or error on failure.
// Note that this method will not fail if an object is not found (e.g. already removed).
// In case you need to strictly check whether all of the objects exist before removing them,
// you can execute multiple box.Contains() and box.Remove() inside a single write transaction.
func (box *TestStringIdEntityBox) RemoveMany(objects ...*TestStringIdEntity) (uint64, error) {
	var ids = make([]uint64, len(objects))
	for k, object := range objects {
		ids[k] = objectbox.StringIdConvertToDatabaseValue(object.Id)
	}
	return box.Box.RemoveIds(ids...)
}

// Creates a query with the given conditions. Use the fields of the TestStringIdEntity_ struct to create conditions.
// Keep the *TestStringIdEntityQuery if you intend to execute the query multiple times.
// Note: this function panics if you try to create illegal queries; e.g. use properties of an alien type.
// This is typically a programming error. Use QueryOrError instead if you want the explicit error check.
func (box *TestStringIdEntityBox) Query(conditions ...objectbox.Condition) *TestStringIdEntityQuery {
	return &TestStringIdEntityQuery{
		box.Box.Query(conditions...),
	}
}

// Creates a query with the given conditions. Use the fields of the TestStringIdEntity_ struct to create conditions.
// Keep the *TestStringIdEntityQuery if you intend to execute the query multiple times.
func (box *TestStringIdEntityBox) QueryOrError(conditions ...objectbox.Condition) (*TestStringIdEntityQuery, error) {
	if query, err := box.Box.QueryOrError(conditions...); err != nil {
		return nil, err
	} else {
		return &TestStringIdEntityQuery{query}, nil
	}
}

// Query provides a way to search stored objects
//
// For example, you can find all TestStringIdEntity which Id is either 42 or 47:
// 		box.Query(TestStringIdEntity_.Id.In(42, 47)).Find()
type TestStringIdEntityQuery struct {
	*objectbox.Query
}

// Find returns all objects matching the query
func (query *TestStringIdEntityQuery) Find() ([]*TestStringIdEntity, error) {
	objects, err := query.Query.Find()
	if err != nil {
		return nil, err
	}
	return objects.([]*TestStringIdEntity), nil
}

// Offset defines the index of the first object to process (how many objects to skip)
func (query *TestStringIdEntityQuery) Offset(offset uint64) *TestStringIdEntityQuery {
	query.Query.Offset(offset)
	return query
}

// Limit sets the number of elements to process by the query
func (query *TestStringIdEntityQuery) Limit(limit uint64) *TestStringIdEntityQuery {
	query.Query.Limit(limit)
	return query
}

type testEntityInline_EntityInfo struct {
	objectbox.Entity
	Uid uint64
}

var TestEntityInlineBinding = testEntityInline_EntityInfo{
	Entity: objectbox.Entity{
		Id: 4,
	},
	Uid: 7566870022778519807,
}

// TestEntityInline_ contains type-based Property helpers to facilitate some common operations such as Queries.
var TestEntityInline_ = struct {
	Date  *objectbox.PropertyInt64
	Value *objectbox.PropertyFloat64
	Id    *objectbox.PropertyUint64
}{
	Date: &objectbox.PropertyInt64{
		BaseProperty: &objectbox.BaseProperty{
			Id:     1,
			Entity: &TestEntityInlineBinding.Entity,
		},
	},
	Value: &objectbox.PropertyFloat64{
		BaseProperty: &objectbox.BaseProperty{
			Id:     2,
			Entity: &TestEntityInlineBinding.Entity,
		},
	},
	Id: &objectbox.PropertyUint64{
		BaseProperty: &objectbox.BaseProperty{
			Id:     3,
			Entity: &TestEntityInlineBinding.Entity,
		},
	},
}

// GeneratorVersion is called by ObjectBox to verify the compatibility of the generator used to generate this code
func (testEntityInline_EntityInfo) GeneratorVersion() int {
	return 2
}

// AddToModel is called by ObjectBox during model build
func (testEntityInline_EntityInfo) AddToModel(model *objectbox.Model) {
	model.Entity("TestEntityInline", 4, 7566870022778519807)
	model.Property("Date", 10, 1, 6052475349651303914)
	model.Property("Value", 8, 2, 7019205901062172310)
	model.Property("Id", 6, 3, 5298431058949014957)
	model.PropertyFlags(8193)
	model.EntityLastPropertyId(3, 5298431058949014957)
}

// GetId is called by ObjectBox during Put operations to check for existing ID on an object
func (testEntityInline_EntityInfo) GetId(object interface{}) (uint64, error) {
	return object.(*TestEntityInline).Id, nil
}

// SetId is called by ObjectBox during Put to update an ID on an object that has just been inserted
func (testEntityInline_EntityInfo) SetId(object interface{}, id uint64) {
	object.(*TestEntityInline).Id = id
}

// PutRelated is called by ObjectBox to put related entities before the object itself is flattened and put
func (testEntityInline_EntityInfo) PutRelated(ob *objectbox.ObjectBox, object interface{}, id uint64) error {
	return nil
}

// Flatten is called by ObjectBox to transform an object to a FlatBuffer
func (testEntityInline_EntityInfo) Flatten(object interface{}, fbb *flatbuffers.Builder, id uint64) error {
	obj := object.(*TestEntityInline)

	// build the FlatBuffers object
	fbb.StartObject(3)
	fbutils.SetInt64Slot(fbb, 0, obj.BaseWithDate.Date)
	fbutils.SetFloat64Slot(fbb, 1, obj.BaseWithValue.Value)
	fbutils.SetUint64Slot(fbb, 2, id)
	return nil
}

// Load is called by ObjectBox to load an object from a FlatBuffer
func (testEntityInline_EntityInfo) Load(ob *objectbox.ObjectBox, bytes []byte) (interface{}, error) {
	var table = &flatbuffers.Table{
		Bytes: bytes,
		Pos:   flatbuffers.GetUOffsetT(bytes),
	}
	var id = table.GetUint64Slot(8, 0)

	return &TestEntityInline{
		BaseWithDate: BaseWithDate{
			Date: fbutils.GetInt64Slot(table, 4),
		},
		BaseWithValue: &BaseWithValue{
			Value: fbutils.GetFloat64Slot(table, 6),
		},
		Id: id,
	}, nil
}

// MakeSlice is called by ObjectBox to construct a new slice to hold the read objects
func (testEntityInline_EntityInfo) MakeSlice(capacity int) interface{} {
	return make([]*TestEntityInline, 0, capacity)
}

// AppendToSlice is called by ObjectBox to fill the slice of the read objects
func (testEntityInline_EntityInfo) AppendToSlice(slice interface{}, object interface{}) interface{} {
	return append(slice.([]*TestEntityInline), object.(*TestEntityInline))
}

// Box provides CRUD access to TestEntityInline objects
type TestEntityInlineBox struct {
	*objectbox.Box
}

// BoxForTestEntityInline opens a box of TestEntityInline objects
func BoxForTestEntityInline(ob *objectbox.ObjectBox) *TestEntityInlineBox {
	return &TestEntityInlineBox{
		Box: ob.InternalBox(4),
	}
}

// Put synchronously inserts/updates a single object.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the TestEntityInline.Id property on the passed object will be assigned the new ID as well.
func (box *TestEntityInlineBox) Put(object *TestEntityInline) (uint64, error) {
	return box.Box.Put(object)
}

// PutAsync asynchronously inserts/updates a single object.
// When inserting, the TestEntityInline.Id property on the passed object will be assigned the new ID as well.
//
// It's executed on a separate internal thread for better performance.
//
// There are two main use cases:
//
// 1) "Put & Forget:" you gain faster puts as you don't have to wait for the transaction to finish.
//
// 2) Many small transactions: if your write load is typically a lot of individual puts that happen in parallel,
// this will merge small transactions into bigger ones. This results in a significant gain in overall throughput.
//
//
// In situations with (extremely) high async load, this method may be throttled (~1ms) or delayed (<1s).
// In the unlikely event that the object could not be enqueued after delaying, an error will be returned.
//
// Note that this method does not give you hard durability guarantees like the synchronous Put provides.
// There is a small time window (typically 3 ms) in which the data may not have been committed durably yet.
func (box *TestEntityInlineBox) PutAsync(object *TestEntityInline) (uint64, error) {
	return box.Box.PutAsync(object)
}

// PutMany inserts multiple objects in single transaction.
// In case Ids are not set on the objects, they would be assigned automatically (auto-increment).
//
// Returns: IDs of the put objects (in the same order).
// When inserting, the TestEntityInline.Id property on the objects in the slice will be assigned the new IDs as well.
//
// Note: In case an error occurs during the transaction, some of the objects may already have the TestEntityInline.Id assigned
// even though the transaction has been rolled back and the objects are not stored under those IDs.
//
// Note: The slice may be empty or even nil; in both cases, an empty IDs slice and no error is returned.
func (box *TestEntityInlineBox) PutMany(objects []*TestEntityInline) ([]uint64, error) {
	return box.Box.PutMany(objects)
}

// Get reads a single object.
//
// Returns nil (and no error) in case the object with the given ID doesn't exist.
func (box *TestEntityInlineBox) Get(id uint64) (*TestEntityInline, error) {
	object, err := box.Box.Get(id)
	if err != nil {
		return nil, err
	} else if object == nil {
		return nil, nil
	}
	return object.(*TestEntityInline), nil
}

// GetMany reads multiple objects at once.
// If any of the objects doesn't exist, its position in the return slice is nil
func (box *TestEntityInlineBox) GetMany(ids ...uint64) ([]*TestEntityInline, error) {
	objects, err := box.Box.GetMany(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*TestEntityInline), nil
}

// GetAll reads all stored objects
func (box *TestEntityInlineBox) GetAll() ([]*TestEntityInline, error) {
	objects, err := box.Box.GetAll()
	if err != nil {
		return nil, err
	}
	return objects.([]*TestEntityInline), nil
}

// Remove deletes a single object
func (box *TestEntityInlineBox) Remove(object *TestEntityInline) error {
	return box.Box.Remove(object)
}

// RemoveMany deletes multiple objects at once.
// Returns the number of deleted object or error on failure.
// Note that this method will not fail if an object is not found (e.g. already removed).
// In case you need to strictly check whether all of the objects exist before removing them,
// you can execute multiple box.Contains() and box.Remove() inside a single write transaction.
func (box *TestEntityInlineBox) RemoveMany(objects ...*TestEntityInline) (uint64, error) {
	var ids = make([]uint64, len(objects))
	for k, object := range objects {
		ids[k] = object.Id
	}
	return box.Box.RemoveIds(ids...)
}

// Creates a query with the given conditions. Use the fields of the TestEntityInline_ struct to create conditions.
// Keep the *TestEntityInlineQuery if you intend to execute the query multiple times.
// Note: this function panics if you try to create illegal queries; e.g. use properties of an alien type.
// This is typically a programming error. Use QueryOrError instead if you want the explicit error check.
func (box *TestEntityInlineBox) Query(conditions ...objectbox.Condition) *TestEntityInlineQuery {
	return &TestEntityInlineQuery{
		box.Box.Query(conditions...),
	}
}

// Creates a query with the given conditions. Use the fields of the TestEntityInline_ struct to create conditions.
// Keep the *TestEntityInlineQuery if you intend to execute the query multiple times.
func (box *TestEntityInlineBox) QueryOrError(conditions ...objectbox.Condition) (*TestEntityInlineQuery, error) {
	if query, err := box.Box.QueryOrError(conditions...); err != nil {
		return nil, err
	} else {
		return &TestEntityInlineQuery{query}, nil
	}
}

// Query provides a way to search stored objects
//
// For example, you can find all TestEntityInline which Id is either 42 or 47:
// 		box.Query(TestEntityInline_.Id.In(42, 47)).Find()
type TestEntityInlineQuery struct {
	*objectbox.Query
}

// Find returns all objects matching the query
func (query *TestEntityInlineQuery) Find() ([]*TestEntityInline, error) {
	objects, err := query.Query.Find()
	if err != nil {
		return nil, err
	}
	return objects.([]*TestEntityInline), nil
}

// Offset defines the index of the first object to process (how many objects to skip)
func (query *TestEntityInlineQuery) Offset(offset uint64) *TestEntityInlineQuery {
	query.Query.Offset(offset)
	return query
}

// Limit sets the number of elements to process by the query
func (query *TestEntityInlineQuery) Limit(limit uint64) *TestEntityInlineQuery {
	query.Query.Limit(limit)
	return query
}

type testEntityRelated_EntityInfo struct {
	objectbox.Entity
	Uid uint64
}

var TestEntityRelatedBinding = testEntityRelated_EntityInfo{
	Entity: objectbox.Entity{
		Id: 5,
	},
	Uid: 145948658381494339,
}

// TestEntityRelated_ contains type-based Property helpers to facilitate some common operations such as Queries.
var TestEntityRelated_ = struct {
	Id        *objectbox.PropertyUint64
	Name      *objectbox.PropertyString
	Next      *objectbox.RelationToOne
	NextSlice *objectbox.RelationToMany
}{
	Id: &objectbox.PropertyUint64{
		BaseProperty: &objectbox.BaseProperty{
			Id:     1,
			Entity: &TestEntityRelatedBinding.Entity,
		},
	},
	Name: &objectbox.PropertyString{
		BaseProperty: &objectbox.BaseProperty{
			Id:     2,
			Entity: &TestEntityRelatedBinding.Entity,
		},
	},
	Next: &objectbox.RelationToOne{
		Property: &objectbox.BaseProperty{
			Id:     3,
			Entity: &TestEntityRelatedBinding.Entity,
		},
		Target: &EntityByValueBinding.Entity,
	},
	NextSlice: &objectbox.RelationToMany{
		Id:     6,
		Source: &TestEntityRelatedBinding.Entity,
		Target: &EntityByValueBinding.Entity,
	},
}

// GeneratorVersion is called by ObjectBox to verify the compatibility of the generator used to generate this code
func (testEntityRelated_EntityInfo) GeneratorVersion() int {
	return 2
}

// AddToModel is called by ObjectBox during model build
func (testEntityRelated_EntityInfo) AddToModel(model *objectbox.Model) {
	model.Entity("TestEntityRelated", 5, 145948658381494339)
	model.Property("Id", 6, 1, 710127486443861244)
	model.PropertyFlags(8193)
	model.Property("Name", 9, 2, 1781092268467778149)
	model.Property("Next", 11, 3, 3103593908461833729)
	model.PropertyFlags(8192)
	model.PropertyRelation("EntityByValue", 4, 3414034888235702623)
	model.EntityLastPropertyId(3, 3103593908461833729)
	model.Relation(6, 3119566795324383223, EntityByValueBinding.Id, EntityByValueBinding.Uid)
}

// GetId is called by ObjectBox during Put operations to check for existing ID on an object
func (testEntityRelated_EntityInfo) GetId(object interface{}) (uint64, error) {
	return object.(*TestEntityRelated).Id, nil
}

// SetId is called by ObjectBox during Put to update an ID on an object that has just been inserted
func (testEntityRelated_EntityInfo) SetId(object interface{}, id uint64) {
	object.(*TestEntityRelated).Id = id
}

// PutRelated is called by ObjectBox to put related entities before the object itself is flattened and put
func (testEntityRelated_EntityInfo) PutRelated(ob *objectbox.ObjectBox, object interface{}, id uint64) error {
	if rel := object.(*TestEntityRelated).Next; rel != nil {
		if rId, err := EntityByValueBinding.GetId(rel); err != nil {
			return err
		} else if rId == 0 {
			// NOTE Put/PutAsync() has a side-effect of setting the rel.ID
			if _, err := BoxForEntityByValue(ob).Put(rel); err != nil {
				return err
			}
		}
	}
	if err := BoxForTestEntityRelated(ob).RelationReplace(TestEntityRelated_.NextSlice, id, object, object.(*TestEntityRelated).NextSlice); err != nil {
		return err
	}

	return nil
}

// Flatten is called by ObjectBox to transform an object to a FlatBuffer
func (testEntityRelated_EntityInfo) Flatten(object interface{}, fbb *flatbuffers.Builder, id uint64) error {
	obj := object.(*TestEntityRelated)
	var offsetName = fbutils.CreateStringOffset(fbb, obj.Name)

	var rIdNext uint64
	if rel := obj.Next; rel != nil {
		if rId, err := EntityByValueBinding.GetId(rel); err != nil {
			return err
		} else {
			rIdNext = rId
		}
	}

	// build the FlatBuffers object
	fbb.StartObject(3)
	fbutils.SetUint64Slot(fbb, 0, id)
	fbutils.SetUOffsetTSlot(fbb, 1, offsetName)
	if obj.Next != nil {
		fbutils.SetUint64Slot(fbb, 2, rIdNext)
	}
	return nil
}

// Load is called by ObjectBox to load an object from a FlatBuffer
func (testEntityRelated_EntityInfo) Load(ob *objectbox.ObjectBox, bytes []byte) (interface{}, error) {
	var table = &flatbuffers.Table{
		Bytes: bytes,
		Pos:   flatbuffers.GetUOffsetT(bytes),
	}
	var id = table.GetUint64Slot(4, 0)

	var relNext *EntityByValue
	if rId := fbutils.GetUint64PtrSlot(table, 8); rId != nil && *rId > 0 {
		if rObject, err := BoxForEntityByValue(ob).Get(*rId); err != nil {
			return nil, err
		} else {
			relNext = rObject
		}
	}

	var relNextSlice []EntityByValue
	if rIds, err := BoxForTestEntityRelated(ob).RelationIds(TestEntityRelated_.NextSlice, id); err != nil {
		return nil, err
	} else if rSlice, err := BoxForEntityByValue(ob).GetMany(rIds...); err != nil {
		return nil, err
	} else {
		relNextSlice = rSlice
	}

	return &TestEntityRelated{
		Id:        id,
		Name:      fbutils.GetStringSlot(table, 6),
		Next:      relNext,
		NextSlice: relNextSlice,
	}, nil
}

// MakeSlice is called by ObjectBox to construct a new slice to hold the read objects
func (testEntityRelated_EntityInfo) MakeSlice(capacity int) interface{} {
	return make([]*TestEntityRelated, 0, capacity)
}

// AppendToSlice is called by ObjectBox to fill the slice of the read objects
func (testEntityRelated_EntityInfo) AppendToSlice(slice interface{}, object interface{}) interface{} {
	return append(slice.([]*TestEntityRelated), object.(*TestEntityRelated))
}

// Box provides CRUD access to TestEntityRelated objects
type TestEntityRelatedBox struct {
	*objectbox.Box
}

// BoxForTestEntityRelated opens a box of TestEntityRelated objects
func BoxForTestEntityRelated(ob *objectbox.ObjectBox) *TestEntityRelatedBox {
	return &TestEntityRelatedBox{
		Box: ob.InternalBox(5),
	}
}

// Put synchronously inserts/updates a single object.
// In case the Id is not specified, it would be assigned automatically (auto-increment).
// When inserting, the TestEntityRelated.Id property on the passed object will be assigned the new ID as well.
func (box *TestEntityRelatedBox) Put(object *TestEntityRelated) (uint64, error) {
	return box.Box.Put(object)
}

// PutAsync asynchronously inserts/updates a single object.
// When inserting, the TestEntityRelated.Id property on the passed object will be assigned the new ID as well.
//
// It's executed on a separate internal thread for better performance.
//
// There are two main use cases:
//
// 1) "Put & Forget:" you gain faster puts as you don't have to wait for the transaction to finish.
//
// 2) Many small transactions: if your write load is typically a lot of individual puts that happen in parallel,
// this will merge small transactions into bigger ones. This results in a significant gain in overall throughput.
//
//
// In situations with (extremely) high async load, this method may be throttled (~1ms) or delayed (<1s).
// In the unlikely event that the object could not be enqueued after delaying, an error will be returned.
//
// Note that this method does not give you hard durability guarantees like the synchronous Put provides.
// There is a small time window (typically 3 ms) in which the data may not have been committed durably yet.
func (box *TestEntityRelatedBox) PutAsync(object *TestEntityRelated) (uint64, error) {
	return box.Box.PutAsync(object)
}

// PutMany inserts multiple objects in single transaction.
// In case Ids are not set on the objects, they would be assigned automatically (auto-increment).
//
// Returns: IDs of the put objects (in the same order).
// When inserting, the TestEntityRelated.Id property on the objects in the slice will be assigned the new IDs as well.
//
// Note: In case an error occurs during the transaction, some of the objects may already have the TestEntityRelated.Id assigned
// even though the transaction has been rolled back and the objects are not stored under those IDs.
//
// Note: The slice may be empty or even nil; in both cases, an empty IDs slice and no error is returned.
func (box *TestEntityRelatedBox) PutMany(objects []*TestEntityRelated) ([]uint64, error) {
	return box.Box.PutMany(objects)
}

// Get reads a single object.
//
// Returns nil (and no error) in case the object with the given ID doesn't exist.
func (box *TestEntityRelatedBox) Get(id uint64) (*TestEntityRelated, error) {
	object, err := box.Box.Get(id)
	if err != nil {
		return nil, err
	} else if object == nil {
		return nil, nil
	}
	return object.(*TestEntityRelated), nil
}

// GetMany reads multiple objects at once.
// If any of the objects doesn't exist, its position in the return slice is nil
func (box *TestEntityRelatedBox) GetMany(ids ...uint64) ([]*TestEntityRelated, error) {
	objects, err := box.Box.GetMany(ids...)
	if err != nil {
		return nil, err
	}
	return objects.([]*TestEntityRelated), nil
}

// GetAll reads all stored objects
func (box *TestEntityRelatedBox) GetAll() ([]*TestEntityRelated, error) {
	objects, err := box.Box.GetAll()
	if err != nil {
		return nil, err
	}
	return objects.([]*TestEntityRelated), nil
}

// Remove deletes a single object
func (box *TestEntityRelatedBox) Remove(object *TestEntityRelated) error {
	return box.Box.Remove(object)
}

// RemoveMany deletes multiple objects at once.
// Returns the number of deleted object or error on failure.
// Note that this method will not fail if an object is not found (e.g. already removed).
// In case you need to strictly check whether all of the objects exist before removing them,
// you can execute multiple box.Contains() and box.Remove() inside a single write transaction.
func (box *TestEntityRelatedBox) RemoveMany(objects ...*TestEntityRelated) (uint64, error) {
	var ids = make([]uint64, len(objects))
	for k, object := range objects {
		ids[k] = object.Id
	}
	return box.Box.RemoveIds(ids...)
}

// Creates a query with the given conditions. Use the fields of the TestEntityRelated_ struct to create conditions.
// Keep the *TestEntityRelatedQuery if you intend to execute the query multiple times.
// Note: this function panics if you try to create illegal queries; e.g. use properties of an alien type.
// This is typically a programming error. Use QueryOrError instead if you want the explicit error check.
func (box *TestEntityRelatedBox) Query(conditions ...objectbox.Condition) *TestEntityRelatedQuery {
	return &TestEntityRelatedQuery{
		box.Box.Query(conditions...),
	}
}

// Creates a query with the given conditions. Use the fields of the TestEntityRelated_ struct to create conditions.
// Keep the *TestEntityRelatedQuery if you intend to execute the query multiple times.
func (box *TestEntityRelatedBox) QueryOrError(conditions ...objectbox.Condition) (*TestEntityRelatedQuery, error) {
	if query, err := box.Box.QueryOrError(conditions...); err != nil {
		return nil, err
	} else {
		return &TestEntityRelatedQuery{query}, nil
	}
}

// Query provides a way to search stored objects
//
// For example, you can find all TestEntityRelated which Id is either 42 or 47:
// 		box.Query(TestEntityRelated_.Id.In(42, 47)).Find()
type TestEntityRelatedQuery struct {
	*objectbox.Query
}

// Find returns all objects matching the query
func (query *TestEntityRelatedQuery) Find() ([]*TestEntityRelated, error) {
	objects, err := query.Query.Find()
	if err != nil {
		return nil, err
	}
	return objects.([]*TestEntityRelated), nil
}

// Offset defines the index of the first object to process (how many objects to skip)
func (query *TestEntityRelatedQuery) Offset(offset uint64) *TestEntityRelatedQuery {
	query.Query.Offset(offset)
	return query
}

// Limit sets the number of elements to process by the query
func (query *TestEntityRelatedQuery) Limit(limit uint64) *TestEntityRelatedQuery {
	query.Query.Limit(limit)
	return query
}
