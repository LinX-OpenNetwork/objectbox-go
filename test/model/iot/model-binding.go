// automatically generated by the ObjectBox, do not modify

package iot

import (
	"github.com/google/flatbuffers/go"
	"github.com/objectbox/objectbox-go/objectbox"
	"github.com/objectbox/objectbox-go/objectbox/fbutils"
)

type EventBinding struct {
}

func (EventBinding) AddToModel(model *objectbox.Model) {
	model.Entity("Event", 1, 1468539308767086854)
	model.Property("Id", objectbox.PropertyType_Long, 1, 3098166604415018001)
	model.PropertyFlags(objectbox.PropertyFlags_ID)
	model.Property("Device", objectbox.PropertyType_String, 2, 1213411729427304641)
	model.Property("Date", objectbox.PropertyType_Date, 3, 5907655274386702697)
	model.EntityLastPropertyId(3, 5907655274386702697)
}

func asEvent(entity interface{}) (*Event, error) {
	ent, ok := entity.(*Event)
	if !ok {
		// Programming error, OK to panic
		// TODO don't panic here, handle in the caller if necessary to panic
		panic("Object has wrong type, expecting 'Event'")
	}
	return ent, nil
}

func asEvents(entities interface{}) ([]*Event, error) {
	ent, ok := entities.([]*Event)
	if !ok {
		// Programming error, OK to panic
		// TODO don't panic here, handle in the caller if necessary to panic
		panic("Object has wrong type, expecting 'Event'")
	}
	return ent, nil
}

func (EventBinding) GetId(entity interface{}) (uint64, error) {
	if ent, err := asEvent(entity); err != nil {
		return 0, err
	} else {
		return ent.Id, nil
	}
}

func (EventBinding) Flatten(entity interface{}, fbb *flatbuffers.Builder, id uint64) {
	ent, err := asEvent(entity)
	if err != nil {
		// TODO return error and panic in the caller if really, really necessary
		panic(err)
	}

	// prepare the "offset" properties
	var offsetDevice = fbutils.CreateStringOffset(fbb, ent.Device)

	// build the FlatBuffers object
	fbb.StartObject(3)
	fbb.PrependUint64Slot(0, id, 0)
	fbb.PrependUOffsetTSlot(1, offsetDevice, 0)
	fbb.PrependInt64Slot(2, ent.Date, 0)
}

func (EventBinding) ToObject(bytes []byte) interface{} {
	table := fbutils.GetRootAsTable(bytes, flatbuffers.UOffsetT(0))

	return &Event{
		Id:     table.OffsetAsUint64(4),
		Device: table.OffsetAsString(6),
		Date:   table.OffsetAsInt64(8),
	}
}

func (EventBinding) MakeSlice(capacity int) interface{} {
	return make([]*Event, 0, capacity)
}

func (EventBinding) AppendToSlice(slice interface{}, entity interface{}) interface{} {
	return append(slice.([]*Event), entity.(*Event))
}

type EventBox struct {
	*objectbox.Box
}

func BoxForEvent(ob *objectbox.ObjectBox) *EventBox {
	return &EventBox{
		Box: ob.Box(1),
	}
}

func (box *EventBox) Get(id uint64) (*Event, error) {
	entity, err := box.Box.Get(id)
	if err != nil {
		return nil, err
	} else if entity == nil {
		return nil, nil
	}
	return asEvent(entity)
}

func (box *EventBox) GetAll() ([]*Event, error) {
	entities, err := box.Box.GetAll()
	if err != nil {
		return nil, err
	}
	return asEvents(entities)
}

func (box *EventBox) Remove(entity *Event) (err error) {
	return box.Box.Remove(entity.Id)
}

type ReadingBinding struct {
}

func (ReadingBinding) AddToModel(model *objectbox.Model) {
	model.Entity("Reading", 2, 5284076134434938613)
	model.Property("Id", objectbox.PropertyType_Long, 1, 3968063745680890327)
	model.PropertyFlags(objectbox.PropertyFlags_ID)
	model.Property("Date", objectbox.PropertyType_Date, 2, 4852407661923085028)
	model.Property("EventId", objectbox.PropertyType_Long, 3, 1403806151574554320)
	model.Property("ValueName", objectbox.PropertyType_String, 4, 5626221656121286670)
	model.Property("ValueString", objectbox.PropertyType_String, 5, 7303099924122013060)
	model.Property("ValueInteger", objectbox.PropertyType_Long, 6, 1404333021836291657)
	model.Property("ValueFloating", objectbox.PropertyType_Double, 7, 7102253623343671118)
	model.EntityLastPropertyId(7, 7102253623343671118)
}

func asReading(entity interface{}) (*Reading, error) {
	ent, ok := entity.(*Reading)
	if !ok {
		// Programming error, OK to panic
		// TODO don't panic here, handle in the caller if necessary to panic
		panic("Object has wrong type, expecting 'Reading'")
	}
	return ent, nil
}

func asReadings(entities interface{}) ([]*Reading, error) {
	ent, ok := entities.([]*Reading)
	if !ok {
		// Programming error, OK to panic
		// TODO don't panic here, handle in the caller if necessary to panic
		panic("Object has wrong type, expecting 'Reading'")
	}
	return ent, nil
}

func (ReadingBinding) GetId(entity interface{}) (uint64, error) {
	if ent, err := asReading(entity); err != nil {
		return 0, err
	} else {
		return ent.Id, nil
	}
}

func (ReadingBinding) Flatten(entity interface{}, fbb *flatbuffers.Builder, id uint64) {
	ent, err := asReading(entity)
	if err != nil {
		// TODO return error and panic in the caller if really, really necessary
		panic(err)
	}

	// prepare the "offset" properties
	var offsetValueName = fbutils.CreateStringOffset(fbb, ent.ValueName)
	var offsetValueString = fbutils.CreateStringOffset(fbb, ent.ValueString)

	// build the FlatBuffers object
	fbb.StartObject(7)
	fbb.PrependUint64Slot(0, id, 0)
	fbb.PrependInt64Slot(1, ent.Date, 0)
	fbb.PrependUint64Slot(2, ent.EventId, 0)
	fbb.PrependUOffsetTSlot(3, offsetValueName, 0)
	fbb.PrependUOffsetTSlot(4, offsetValueString, 0)
	fbb.PrependInt64Slot(5, ent.ValueInteger, 0)
	fbb.PrependFloat64Slot(6, ent.ValueFloating, 0)
}

func (ReadingBinding) ToObject(bytes []byte) interface{} {
	table := fbutils.GetRootAsTable(bytes, flatbuffers.UOffsetT(0))

	return &Reading{
		Id:            table.OffsetAsUint64(4),
		Date:          table.OffsetAsInt64(6),
		EventId:       table.OffsetAsUint64(8),
		ValueName:     table.OffsetAsString(10),
		ValueString:   table.OffsetAsString(12),
		ValueInteger:  table.OffsetAsInt64(14),
		ValueFloating: table.OffsetAsFloat64(16),
	}
}

func (ReadingBinding) MakeSlice(capacity int) interface{} {
	return make([]*Reading, 0, capacity)
}

func (ReadingBinding) AppendToSlice(slice interface{}, entity interface{}) interface{} {
	return append(slice.([]*Reading), entity.(*Reading))
}

type ReadingBox struct {
	*objectbox.Box
}

func BoxForReading(ob *objectbox.ObjectBox) *ReadingBox {
	return &ReadingBox{
		Box: ob.Box(2),
	}
}

func (box *ReadingBox) Get(id uint64) (*Reading, error) {
	entity, err := box.Box.Get(id)
	if err != nil {
		return nil, err
	}
	return asReading(entity)
}

func (box *ReadingBox) GetAll() ([]*Reading, error) {
	entities, err := box.Box.GetAll()
	if err != nil {
		return nil, err
	}
	return asReadings(entities)
}

func (box *ReadingBox) Remove(entity *Reading) (err error) {
	return box.Box.Remove(entity.Id)
}
